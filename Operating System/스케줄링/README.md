# 1. 스케줄링 알고리즘
### 1) 정의
- CPU가 Multiprogramming으로 동작할 때, 여러 프로세스나 스레드가 Ready 상태인 경우 어떤 것을 실행할지 선택하는 `스케줄러`의 알고리즘
- 이때, 스케줄러는 운영체제의 일부분임
### 2) 등장 배경
- 과거 배치 시스템 시절
  - CPU가 희귀해서 스케줄링 알고리즘 개발 활발했음
- 개인용 컴퓨터의 등장
  - 하나의 활성화된 프로세스만 존재하고 CPU는 발라져 스케줄링 알고리즘 개발 필요성 잠깐 줄어들었음
- 최근 고성능 workstation과 서버 컴퓨터 등장
  - 다수의 프로세스가 CPU 놓고 경쟁해서 스케줄링 다시 중요해짐
### 3) 발생 시점
- 프로세스 `생성`할 때 -> 생성한 프로세스와 기존 프로세스 중 선택해야 함
  - 부모 프로세스가 fork 시스템 콜을 하면 클론이 생겨서 자식 프로세스가 생성됨
  - 스케줄링은 부모 프로세스를 계속 실행할지, 자식 프로세스를 실행할지 선택해야 함 (이때, 자식과 부모는 둘 다 Ready 상태임)
- 프로세스 `종료`할 때 -> 종료한 프로세스를 대체할 프로세스를 선택해야 함
  - 프로세스가 더 이상 존재하지 않아 수행할 수 없기에, Ready 상태의 다른 프로세스가 선택되어 Running 상태로 가야 함
- 프로세스 `Block` 될 때 -> Block된 프로세스르 대체할 프로세스를 선택해야 함
  - 프로세스가 I/O, 세마포어 등과 같은 무언가 때문에 Block 상태로 가면, Ready 상태의 다른 프로세스가 선택되어 Running 상태로 가야 함
- `I/O 인터럽트`가 발생했을 때
  - I/O가 완료되면 `I/O 인터럽드`가 발생함
  - I/O가 완료되길 기다리며 Block되어 있던 프로세스가 이제 실행할 준비가 되어 Ready 상태로 옴
  - 이때 I/O 인터럽트 발생 당시 실행하던 프로세스를 계속 실행할지, 새로 Ready로 온 프로세스를 실행할지 선택해야 함
    - 일반적으론 I/O 인터럽트 때문에 억울하게 중지된 기존 프로세스를 선택함

# 2. Process Switching (Context Switching)
- 정의) Running 상태의 프로세스를 끌어내리고 Ready 상태의 프로세스를 Running으로 올려주는 것
- 특징) Expensive해서 `스케줄링` 잘해줘야 함
- 과정) 
    - user 모드에서 Kernel 모드로 전환
    - 프로세스 테이블에 현재 끌어내릴 프로세스의 상태를 store 함
    - `스케줄링 알고리즘` 실행해 새 프로세스 선택
    - 새 프로세스의 저장 상태 load 해와서 실행시킴

# 3. 스케줄링 알고리즘의 분류
### 1) Clock Interrupt 처리 유무에 따라 분류
- Clock Interrupt
  - 하드웨어 Clock이 주기적으로 Clock Interrupt를 발생시킴
  - 매 Clock Interrupt 혹은 K번째 Clock Interrupt마다 스케줄링 결정 이루어짐
- Nonpreemptive(비선점) 스케줄링 알고리즘 : `Clock Interrupt 처리 X`
  - 실행 프로세스는 Block되거나 자발적으로 CPU 내놓을 때까지 계속 실행될 수 있음
  - 수 시간동안 계속 수행해도 강제 중단 안됨
- Preemptive(선점형) 스케줄링 알고리즘 : `Clock Interrupt 처리 O`
  - 실행 프로세스는 할당된 시간을 넘지 않는 범위에서 실행됨
  - 할당된 시간 다 되면 중단되어 Ready 상태로 끌어내려짐
### 2) 시스템 환경에 따라 분류
- 배치(Batch) 시스템
  - 목표)
    - `반환 시간(Turnaround Time)` 최소화
    - `시간 당 처리 작업 수(Throughput)` 최소화
- 대화식(Interactive) 시스템
  - 목표)
    - `응답 시간(Response Time)` 최소화
- 실시간(Real time) 시스템
  - 목표)
    - `마감 시간` 만족

# 4. 배치(Batch) 시스템의 스케줄링 알고리즘
### 1) 선입선출 (First-Come First-Served)
- 정의) Ready 큐에 `먼저` 온 프로세스를 먼저 처리함
- 특징) Nonpreemptive
### 2) 최단작업우선(Shortest Job First)
- 정의) Ready 큐에서 `실행시간` 짧은 작업부터 먼저 수행함
- 특징)
  - Nonpreemptive
  - 실행시간을 미리 알아야 함
  - 모두 동시에 도착했다면 최소화된 평균 `반환 시간(Turnaround Time)` 제공함
### 3) 최단잔여시간우선(Shortest Remaining Time Next)
- 정의) Ready 큐에서 남은 `잔여시간`이 짧은 작업을 택함
- 특징)
  - Preemptive
  - 중간에 새로운 작업 들어오면, 새 작업의 실행시간과 현재 수행 중인 작업의 남은 시간을 비교함

# 5. 대화식(Interactive) 시스템의 스케줄링 알고리즘
### 1) 라운드 로빈 스케줄링(Round-Robin Scheduling)
- 정의) 모든 프로세스에게 똑같은 `시간 할당량(Quantum)`을 줘서 돌아가면서 수행되게 함
- 특징)
  - Preemptive
  - `시간 할당량` 길이에 따른 효과
    - `짧은 경우` : `Switch`가 많이 일어남 -> CPU 효율이 떨어짐
    - `긴 경우` : `응답 시간(Response Time)`이 느려짐
### 2) 우선순위 스케줄링(Priority Scheduling)
- 정의) `우선순위` 높은 프로세스부터 수행함
- 특징)
  - Preemptive
  - `우선순위 클래스`를 사용함
    - 모든 프로세스들은 특정 클래스에 속함
    - 클래스들 간엔 우선순위가 정해져 있음
    - 우선순위가 높은 클래스에 속한 프로세스들부터 우선 실행함 -> `우선순위 스케줄링`
    - 같은 클래스에 속한 프로세스들끼린 `라운드로빈 스케줄링` 사용함
  - `우선순위 클래스` 방식을 응용한 `다단계 큐` 방식을 사용한 시스템인 `CTSS`라는 게 있음
### 3) 최단프로세스순번(Shortest Process Next)
- 정의) `예상 실행 시간`이 짧은 작업부터 실행함
- 특징)
  - 실행 시간 예상할 때 `Aging 기법` 사용함
    - 이전 예상치와 현재 측정된 값을 가중 평균해 연속적으로 다음 값을 예상하는 기법
### 4) 보장 스케줄링(Guaranted Scheduling) 
### 5) 복권 스케줄링(Lottery Scheduling)
### 6) 공평-몫 스케줄링(Fair-Share Scheduling)

# 6. 실시간(Real time) 시스템에서 스케줄링
### 1) 스케줄 가능한 실시간 시스템
- 정의) 각 프로세스에 의해 사용되는 CPU의 Fraction의 합이 1 이하일 때 `스케줄 가능`하다고 함
- 예시)
  ![image](https://user-images.githubusercontent.com/83302344/227783963-16fb45cb-3cf7-439c-bd7b-e63f97eedee9.png)
  ![image](https://user-images.githubusercontent.com/83302344/227784004-c8055742-ca63-4cb0-ae67-ee77c627726b.png)


# 7. 스레드 스케줄링(Thread Scheduling)
### 1) 유저 레벨 스레드 스케줄링
- 장점) 유저 레벨에서 스케줄링 일어나서 성능 좋음
- 단점) 스레드가 io 요청하면 커널은 프로세스만 봐서 프로세스 전체가 중지됨
### 2) 커널 레벨 스레드 스케줄링
- 장점) 커널 자체가 스레드 하나 하나의 존재를 알고 스케줄링함. 스레드가 io 요청해도 프로세스 전체가 중지되는 게 아닌 해당 스레드만 중지되어 해당 프로세스의 다른 스레드 수행 가능함
- 단점) 유저 모드에서 커널 모드로의 전환이 빈번하게 이뤄져 성능 저하가 발생

# 출처
- 작년 운체 수업 듣고 정리해 둔 것 보고 하나하나 직접 다시 쓰면서 좀 더 보기 편하게 정리해봤어요
